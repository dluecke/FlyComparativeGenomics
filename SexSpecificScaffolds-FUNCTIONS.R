# SexSpecificScaffolds-FUNCTIONS.R
# functions for testing scaffold depth and variant data for sex chromosome signals

# make_df.sexbias() a function to build the df.sexbias dataframe
# depth and variant calls from read mapping against hardmasked assembly
# takes a list of 5 filenames, all generated by Ceres scripts: 
#   nmasked: nmasked.csv file with per-scaffold lengths and masked bp counts
#   depthF: depth_per_scaffold.tsv from female reads against hardmasked assembly
#   depthM: depth_per_scaffold.tsv from male reads against hardmasked assembly
#     depth_per_scaffold.tsv w/ 3 columns: scaffold n_sites depth -- via get_depth_scaffold.sh
#     (needed to account for ambiguity reporting in masked or depth=0 sites)
#   nvariF: nseg_per_scaffold.csv from female reads, count of variant sites of hardmasked scaffolds
#   nvariM: nseg_per_scaffold.csv from male reads, count of variant sites of hardmasked scaffolds
# reads in all files, sorts by scaffold length, calculates for each scaffold:
#   - total length, masked bp, unmasked length
#   - proportion of total assembly length
#   - proportion of unmasked assembly length
#   - female and male normalized depths (to unmasked length-weighted average depth)
#   - female and male frequency of variant sites
#   - F/M ratio of normalized depth
#   - F/M ratio of variant frequency 
make_df.sexbias <- function(l.IN_FILES){
  # get scaffolds and lengths from asm fasta index
  NMASKED <- read.csv(l.IN_FILES$nmasked, header = F,
                      col.names = c('scaffold', 'length', 'masked'))
  NMASKED$unmasked <- NMASKED$length - NMASKED$masked
  NMASKED <- NMASKED[order(-NMASKED$unmasked),]
  # input dataframes
  IN_DEPTHF <- read.table(l.IN_FILES$depthF, header = F, row.names = 1, 
                          col.names = c('scaffold', 'n_sites', 'depth'))
  IN_DEPTHM <- read.table(l.IN_FILES$depthM, header = F, row.names = 1, 
                          col.names = c('scaffold', 'n_sites', 'depth'))
  IN_NVARIF <- read.csv(l.IN_FILES$nvariF, header = F, row.names = 1, 
                        col.names = c('scaffold','n_variants'))
  IN_NVARIM <- read.csv(l.IN_FILES$nvariM, header = F, row.names = 1, 
                        col.names = c('scaffold','n_variants'))
  # scaffolds ordered by length
  SCAFFOLDS <- NMASKED$scaffold
  # start output df ordered by scaffold length
  SEXBIAS <- data.frame(length = NMASKED$length,
                        masked = NMASKED$masked,
                        unmasked = NMASKED$unmasked,
                        nsitesF = IN_DEPTHF[SCAFFOLDS,]$n_sites,
                        depthF = IN_DEPTHF[SCAFFOLDS,]$depth,
                        nsitesM = IN_DEPTHM[SCAFFOLDS,]$n_sites,
                        depthM = IN_DEPTHM[SCAFFOLDS,]$depth,
                        n_varF = IN_NVARIF[SCAFFOLDS,],
                        n_varM = IN_NVARIM[SCAFFOLDS,],
                        row.names = SCAFFOLDS)
  # treat missing values as 0
  SEXBIAS[is.na(SEXBIAS)] = 0
  # proportion of total length per scaffold
  SEXBIAS$pr_length <- SEXBIAS$length / sum(SEXBIAS$length)
  # proportion of unmasked length per scaffold
  SEXBIAS$pr_unmasked <- SEXBIAS$unmasked / sum(SEXBIAS$unmasked)
  # unmasked length-weighted normalized depths
  SEXBIAS$depthF_n <- SEXBIAS$depthF / sum(SEXBIAS$depthF * SEXBIAS$pr_unmasked)
  SEXBIAS$depthM_n <- SEXBIAS$depthM / sum(SEXBIAS$depthM * SEXBIAS$pr_unmasked)
  # frequency of variant sites per kb
  SEXBIAS$fr_varF <- 1000 * SEXBIAS$n_varF / SEXBIAS$unmasked
  SEXBIAS$fr_varM <- 1000 * SEXBIAS$n_varM / SEXBIAS$unmasked
  # frequency of variants per kb, normalized to library average
  SEXBIAS$fr_varF_n <- SEXBIAS$fr_varF / (1000 * sum(SEXBIAS$n_varF)/sum(SEXBIAS$unmasked))
  SEXBIAS$fr_varM_n <- SEXBIAS$fr_varM / (1000 * sum(SEXBIAS$n_varM)/sum(SEXBIAS$unmasked))
  # sex bias (female / male)
  SEXBIAS$Depth_bias <- SEXBIAS$depthF_n / SEXBIAS$depthM_n
  SEXBIAS$FrVar_bias <- SEXBIAS$fr_varF_n / SEXBIAS$fr_varM_n
  
  return(SEXBIAS)
  
}


# Function to combine stats from df.SexBias across list of scaffolds
# Used in make_df.HomologSexBias() inside sapply call
ClusterStats <- function(SCAF_LIST, DF.SEXBIAS){
  cbind( nscafs = length(SCAF_LIST), 
         longest = SCAF_LIST[order(-DF.SEXBIAS[SCAF_LIST,]$length)][1],
         DF.SEXBIAS[SCAF_LIST,] %>% 
           summarise(total.bp = sum(length), 
                     unmasked.bp = sum(unmasked),
                     pr_length = sum(pr_length),
                     pr_unmasked = sum(pr_unmasked),
                     depth_raw.F = sum(unmasked*depthF/sum(unmasked)),
                     depth_raw.M = sum(unmasked*depthM/sum(unmasked)),
                     var_count.F = sum(n_varF), 
                     var_count.M = sum(n_varM),
                     var_fr.F = sum(n_varF)/sum(unmasked),
                     var_fr.M = sum(n_varM)/sum(unmasked),
                     depth_n.F = sum(unmasked*depthF_n/sum(unmasked)), 
                     depth_n.M = sum(unmasked*depthM_n/sum(unmasked)), 
                     var_n.F = sum(unmasked*fr_varF_n/sum(unmasked)), 
                     var_n.M = sum(unmasked*fr_varM_n/sum(unmasked)))
  )
}

# function to make df with composite stats for homolog clusters
# takes homolog cluster list from alignment_region_dotplot-FUNCTIONS.R GetHomologs()
#  (my convention in those alignments is ref=M qry=F)
# takes DF.SEXBIAS for each sex from make_df.sexbias
make_df.HomologSexBias <- function(CLUSTERS, DF.SEXBIAS.F, DF.SEXBIAS.M){
  
  DF.HOMOLOGS.F <- sapply(CLUSTERS, function(x){ 
      ClusterStats(x$QryScafs, DF.SEXBIAS.F) 
    }) %>% t() %>% data.frame()
  
  DF.HOMOLOGS.M <- sapply(CLUSTERS, function(x){
      ClusterStats(x$RefScafs, df.SexBias.M )
    }) %>% t() %>% data.frame()
  
  DF.HOMOLOGS <- data.frame(
    F_longest = unlist(DF.HOMOLOGS.F$longest),
    F_nscafs = unlist(DF.HOMOLOGS.F$nscafs),
    F_total.bp = unlist(DF.HOMOLOGS.F$total.bp),
    F_unmasked = unlist(DF.HOMOLOGS.F$unmasked.bp),
    F_pr.length = unlist(DF.HOMOLOGS.F$pr_length),
    F_pr.unmasked = unlist(DF.HOMOLOGS.F$pr_unmasked),
    M_longest = unlist(DF.HOMOLOGS.M$longest),
    M_nscafs = unlist(DF.HOMOLOGS.M$nscafs),
    M_total.bp = unlist(DF.HOMOLOGS.M$total.bp),
    M_unmasked = unlist(DF.HOMOLOGS.M$unmasked),
    M_pr.length = unlist(DF.HOMOLOGS.M$pr_length),
    M_pr.unmasked = unlist(DF.HOMOLOGS.M$pr_unmasked),

    F_depth.raw.F = unlist(DF.HOMOLOGS.F$depth_raw.F),
    F_depth.raw.M = unlist(DF.HOMOLOGS.F$depth_raw.M),
    Fasm_depth.F = unlist(DF.HOMOLOGS.F$depth_n.F),
    Fasm_depth.M = unlist(DF.HOMOLOGS.F$depth_n.M),
    M_depth.raw.F = unlist(DF.HOMOLOGS.M$depth_raw.F),
    M_depth.raw.M = unlist(DF.HOMOLOGS.M$depth_raw.M),
    Masm_depth.F = unlist(DF.HOMOLOGS.M$depth_n.F),
    Masm_depth.M = unlist(DF.HOMOLOGS.M$depth_n.M),
    
    F_var.count.F = unlist(DF.HOMOLOGS.F$var_count.F),
    F_var.count.M = unlist(DF.HOMOLOGS.F$var_count.M),
    F_var.fr.F = unlist(DF.HOMOLOGS.F$var_fr.F),
    F_var.fr.M = unlist(DF.HOMOLOGS.F$var_fr.M),
    Fasm_var.F = unlist(DF.HOMOLOGS.F$var_n.F),
    Fasm_var.M = unlist(DF.HOMOLOGS.F$var_n.M),
    M_var.count.F = unlist(DF.HOMOLOGS.M$var_count.F),
    M_var.count.M = unlist(DF.HOMOLOGS.M$var_count.M),
    M_var.fr.F = unlist(DF.HOMOLOGS.M$var_fr.F),
    M_var.fr.M = unlist(DF.HOMOLOGS.M$var_fr.M),
    Masm_var.F = unlist(DF.HOMOLOGS.M$var_n.F),
    Masm_var.M = unlist(DF.HOMOLOGS.M$var_n.M),
    
    DepthBias_Fasm = (unlist(DF.HOMOLOGS.F$depth_n.F) + 0.001) /
                      (unlist(DF.HOMOLOGS.F$depth_n.M) + 0.001),
    DepthBias_Masm = (unlist(DF.HOMOLOGS.M$depth_n.F) + 0.001) / 
                      (unlist(DF.HOMOLOGS.M$depth_n.M) + 0.001),
    VarBias_Fasm = (unlist(DF.HOMOLOGS.F$var_n.F) + 0.001) / 
                    (unlist(DF.HOMOLOGS.F$var_n.M) + 0.001),
    VarBias_Masm = (unlist(DF.HOMOLOGS.M$var_n.F) + 0.001) / 
                    (unlist(DF.HOMOLOGS.M$var_n.M) + 0.001)
  )
  
  DF.HOMOLOGS$AvgTotalLength <- apply(
    DF.HOMOLOGS[,c('F_total.bp','M_total.bp')], 1, mean, na.rm=T )
  DF.HOMOLOGS$AvgUnmasked <- apply(
    DF.HOMOLOGS[,c('F_unmasked','M_unmasked')], 1, mean, na.rm=T )
  DF.HOMOLOGS$AvgDepthBias <- apply(
    DF.HOMOLOGS[,c('DepthBias_Fasm','DepthBias_Masm')], 1, mean, na.rm=T )
  DF.HOMOLOGS$AvgVarBias <- apply(
    DF.HOMOLOGS[,c('VarBias_Fasm','VarBias_Masm')], 1, mean, na.rm=T )
  
  return(DF.HOMOLOGS[order(-DF.HOMOLOGS$AvgTotalLength),])
}


# function to link depth windows to unmasked lengths and 
#  normalize depths by unmasked-weighted average
make_df.DepthWindows <- function(INFILE_DEPTH, INFILE_NMASKED){
  # read in csv with total and masked bases per window, calculate unmasked per window
  DF.NMASKED <- read.csv(INFILE_NMASKED, header = F, row.names = 1, 
                          col.names = c('window', 'total', 'masked'))
  DF.NMASKED$unmasked <- DF.NMASKED$total - DF.NMASKED$masked
  
  # read in tsv with average depths per window and number sites used
  DF.DEPTH <- read.csv(INFILE_DEPTH, sep = '\t',
                       col.names = c('scaffold', 'position',
                                     'window', 'nsites', 'depth'))
  # add unmasked and total lengths for each window from NMASKED df
  DF.DEPTH$unmasked <- DF.NMASKED[DF.DEPTH$window,]$unmasked
  DF.DEPTH$total <- DF.NMASKED[DF.DEPTH$window,]$total
  # account for missing 0s in depth average
  DF.DEPTH <- DF.DEPTH %>% filter(unmasked > 0) %>% 
    mutate(depth_w0s = depth * nsites/unmasked)
  # length-weighted average depth
  DEPTH_AVG = sum(DF.DEPTH$depth_w0s * DF.DEPTH$unmasked/sum(DF.DEPTH$unmasked))
  # normalize by length-weighed average
  DF.DEPTH <- DF.DEPTH %>% mutate(depth_norm = depth / DEPTH_AVG)
  
  return(DF.DEPTH)
}


# function to link variant count windows to unmasked lengths 
#  and find variant frequencies per unmasked bp
make_df.VariantWindows <- function(INFILE_VARIANT, INFILE_NMASKED){
  # read in csv with total and masked bases per window, calculate unmasked per window
  DF.NMASKED <- read.csv(INFILE_NMASKED, header = F, row.names = 1, 
                         col.names = c('window', 'total', 'masked'))
  DF.NMASKED$unmasked <- DF.NMASKED$total - DF.NMASKED$masked
  
  # read in tsv with variant site count per window 
  DF.VARIANT <- read.csv(INFILE_VARIANT, sep = '\t',
                       col.names = c('scaffold', 'position',
                                     'window', 'n_variants'))
  # add unmasked and total lengths for each window from NMASKED df
  DF.VARIANT$unmasked <- DF.NMASKED[DF.VARIANT$window,]$unmasked
  DF.VARIANT$total <- DF.NMASKED[DF.VARIANT$window,]$total
  # frequency variant sites per window
  DF.VARIANT <- DF.VARIANT %>% mutate(fr_var = n_variants / unmasked)

  return(DF.VARIANT)
}


# Functions for plotting windows data
# make the dataframe for plotting 
make_df.WindowPlots <- function(DF_WINDOWS, SEQ_LIST, MIN_UNMASKED){
  PLOTDF <- DF_WINDOWS %>% filter(scaffold %in% SEQ_LIST, unmasked >= MIN_UNMASKED)
  OFFSETS <- PLOTDF %>% group_by(scaffold) %>% 
    # highest value per scaffold, add 1 for plot spacing
    summarise(lastpos=max(position)+1) %>% arrange(desc(lastpos))
  OFFSETS$offset <- (c(0,OFFSETS$lastpos[1:nrow(OFFSETS)-1]) %>% cumsum())
  PLOTDF$offset <- apply(PLOTDF, 1, function(x){
    OFFSETS$offset[OFFSETS$scaffold == x[1]]
  })
  return(PLOTDF)
}

PlotDepthWindows <- function(DF_WINDOWS, SEQ_LIST, MIN_UNMASKED, 
                             ASSEMBLY_NAME, WINDOW_LABEL,
                             SPAN=0.4, ALPHA=0.05, 
                             Y_MIN='auto', Y_MAX='auto', FLIP_SCAF_LAB = F){
  # get dataframe for plotting
  PLOTDF <- make_df.WindowPlots(DF_WINDOWS, SEQ_LIST, MIN_UNMASKED)
  
  # set color scale for sex based on how many sexes represented
  N_SEX = PLOTDF$sex %>% factor() %>% levels() %>% length()
  if( N_SEX == 2 ){
    SCALE_VALUES = c('red', 'blue')
  } else {
    SCALE_VALUES=c('slateblue')
  }
  
  # set Y min and max based on PLOTDF unless set by command call
  if(Y_MIN == 'auto'){
    Y_MIN <- min(PLOTDF$depth_norm)
  }
  if(Y_MAX == 'auto'){
    Y_MAX <- max(PLOTDF$depth_norm)
  }
  
  if(FLIP_SCAF_LAB){
    ANNO_Y = Y_MAX
    ANNO_ANGLE = 90
    ANNO_HJUST = 1
    ANNO_VJUST = 1.1
  } else {
    ANNO_Y = Y_MIN
    ANNO_ANGLE = 0
    ANNO_HJUST = -0.1
    ANNO_VJUST = 1
  }
  
  # get names and x-positions for scaffold annotation
  OFFSETS <- PLOTDF %>% group_by(scaffold) %>% summarise(offset=max(offset))
  
  PLOT <- ggplot(PLOTDF, aes(x = position+offset, 
                             y = depth_norm, 
                             color = sex, 
                             shape = rep, linetype = rep, 
                             lineend = scaffold)) +
    # point cloud
    geom_point(alpha=ALPHA) + 
    # smoothed lines
    geom_smooth(se=F, method = 'loess', span=SPAN) +
    # improve legibility of legend for rep
    guides(shape = guide_legend(override.aes = list(alpha=0.6, size=3, color='black')) ) +
    # colors for sex (set above)
    scale_color_manual(values = SCALE_VALUES) +
    # lines and labels for sequences
    geom_vline(xintercept = OFFSETS$offset, color='darkgrey', lty=2, linewidth=0.8) +
    annotate("text", label=OFFSETS$scaffold, x=OFFSETS$offset, 
             y = ANNO_Y, angle = ANNO_ANGLE, 
             hjust = ANNO_HJUST, vjust = ANNO_VJUST) +
    # other plot formatting
    coord_cartesian(ylim = c(Y_MIN,Y_MAX)) + 
    theme_light() +
    labs( y = 'normalized depth', 
          x = paste0(ASSEMBLY_NAME, " - ", WINDOW_LABEL, " windows, >", 
                   MIN_UNMASKED, " unmasked bp, loess span=", SPAN) )
  
  return(PLOT)

}


PlotVariantWindows <- function(DF_WINDOWS, SEQ_LIST, MIN_UNMASKED, 
                             ASSEMBLY_NAME, WINDOW_LABEL,
                             SPAN=0.4, ALPHA=0.05, 
                             Y_MIN='auto', Y_MAX='auto', FLIP_SCAF_LAB = F){
  # get dataframe for plotting
  PLOTDF <- make_df.WindowPlots(DF_WINDOWS, SEQ_LIST, MIN_UNMASKED)
  
  # set color scale for sex based on how many sexes represented
  N_SEX = PLOTDF$sex %>% factor() %>% levels() %>% length()
  if( N_SEX == 2 ){
    SCALE_VALUES = c('red', 'blue')
  } else {
    SCALE_VALUES=c('slateblue')
  }

  # set Y min and max based on PLOTDF unless set by command call
  if(Y_MIN == 'auto'){
    Y_MIN <- min(PLOTDF$fr_var)
  }
  if(Y_MAX == 'auto'){
    Y_MAX <- max(PLOTDF$fr_var)
  }
  
  if(FLIP_SCAF_LAB){
    ANNO_Y = Y_MAX
    ANNO_ANGLE = 90
    ANNO_HJUST = 1
    ANNO_VJUST = 1.1
  } else {
    ANNO_Y = Y_MIN
    ANNO_ANGLE = 0
    ANNO_HJUST = -0.1
    ANNO_VJUST = 1
  }
  
  # get names and x-positions for scaffold annotation
  OFFSETS <- PLOTDF %>% group_by(scaffold) %>% summarise(offset=max(offset))
  
  PLOT <- ggplot(PLOTDF, aes(x = position+offset, 
                             y = fr_var, 
                             color = sex, 
                             shape = rep, linetype = rep, 
                             lineend = scaffold)) +
    # point cloud
    geom_point(alpha=ALPHA) + 
    # smoothed lines
    geom_smooth(se=F, method = 'loess', span=SPAN) +
    # improve legibility of legend for rep
    guides(shape = guide_legend(override.aes = list(alpha=0.6, size=3, color='black')) ) +
    # colors for sex (set above)
    scale_color_manual(values = SCALE_VALUES) +
    # lines and labels for sequences
    geom_vline(xintercept = OFFSETS$offset, color='darkgrey', lty=2, linewidth=0.8) +
    annotate("text", label=OFFSETS$scaffold, x=OFFSETS$offset, 
             y = ANNO_Y, angle = ANNO_ANGLE, 
             hjust = ANNO_HJUST, vjust = ANNO_VJUST) +
    # other plot formatting
    coord_cartesian(ylim = c(Y_MIN,Y_MAX)) + 
    theme_light() +
    labs( y = 'frequency variant sites', 
          x = paste0(ASSEMBLY_NAME, " - ", WINDOW_LABEL, " windows, >", 
                     MIN_UNMASKED, " unmasked bp, loess span=", SPAN) )
  
  return(PLOT)
  
}




